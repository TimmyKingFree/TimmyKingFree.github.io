<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>Timmy的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前端前进的路上">
<meta property="og:type" content="website">
<meta property="og:title" content="Timmy的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Timmy的博客">
<meta property="og:description" content="前端前进的路上">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Timmy的博客">
<meta name="twitter:description" content="前端前进的路上">
  
    <link rel="alternative" href="/atom.xml" title="Timmy的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://img.qqai.net/uploads/i_0_2903473236x1549485634_21.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Timmy King</a></h1>
		</hgroup>

		
		<p class="header-subtitle">会写诗的程序员</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/TimmyKingFree/TimmyKingFree.github.io" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/timmy-king/activities" title="zhihu"><i class="icon-zhihu"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-sort"></i></div>
  		<h1 class="header-author js-mobile-header hide">Timmy King</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://img.qqai.net/uploads/i_0_2903473236x1549485634_21.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Timmy King</h1>
			</hgroup>
			
			<p class="header-subtitle">会写诗的程序员</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/TimmyKingFree/TimmyKingFree.github.io" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/timmy-king/activities" title="zhihu"><i class="icon-zhihu"></i></a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-《西游日记》读书笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/03/《西游日记》读书笔记/">《西游日记》读书笔记</a>
    </h1>
  

        <a href="/2017/01/03/《西游日记》读书笔记/" class="archive-article-date">
  	<time datetime="2017-01-03T15:32:26.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-01-03</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>——“师父，我们要去哪儿？”我问。<br>——“我不知道。”<br>——“那我们为什么还要走下去？”<br>——“因为不能停下。”</p>
<p><hr><br>一个人要走多少路，才能成为男子汉。<br>一只白鸽要飞过多少个海洋，她才会躺于沙滩上。<br>一座山要矗立多少年，它才会被冲刷到大海。<br>一群人要生存多少年，他们才会获得自由。</p>
<p><hr><br>今何在西游三部曲的第二部，少了些锋芒，却更加地鲜血淋漓。作者用幽默的语言在化解他想表达的黑暗却真实的西游。他将西游重构了一遍，以唐僧的日记的形式来描写西游。在这个西游里，妖怪不为唐僧肉而抓唐僧，反而为了为了唤醒孙悟空的记忆。<br>白骨精的死让人怜惜，牛魔王与铁扇公主的死让人感觉悲壮。孙悟空最终选择结束自己的生命来知道一切的真相。自毁修行，重入轮回，为的是求一个答案。<br>少了大闹天宫的经典剧情，便少了一份豪情。没有记忆，却有感情。我无法体会孙悟空埋葬白骨精时的心情。但我却觉得白骨精是幸福的，她最终如愿以偿，用自己的生命给孙悟空一个离开西游重返花果山的机会。<br>书中有一个道理，你不自救，没有人能救你。不禁想起最近追的韩剧《不死神灵》里面有一个桥段。一个凡人着急找茅厕，竟然打开了只有亡灵才能打开的死亡使者办公室。人类的意愿是很强烈的，强烈到可以创造奇迹。<br>我做不到唐僧、做不到孙悟空，只愿立下一个小愿，当我可以掌握自己的命运，甚至掌握他人的命运时，不做剥削。<br>作者揭示的现实是残酷的，但是作者的心却是乐观的。没有人知道路该怎么走，但是重要的是路本身而不是终点。常怀积极的心，真正的乐观，是你在见识到了世界上最漆黑的夜之后，仍然相信天会亮，相信天亮之后会很美。<br>我们改变不了时间，改变不了规则，可以改变的只有自己的心，是经历了无数黑夜之后，仍然不悔地相信希望，相信明天的心。明天，也许我看不到，但天终会亮，也终将有人看到天亮。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/01/03/《西游日记》读书笔记/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="w-牧羊少年的奇幻之旅-读书笔记" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/29/牧羊少年的奇幻之旅-读书笔记/">牧羊少年的奇幻之旅-读书笔记</a>
    </h1>
  

        <a href="/2016/12/29/牧羊少年的奇幻之旅-读书笔记/" class="archive-article-date">
  	<time datetime="2016-12-29T13:16:29.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-29</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span style="font-size:20px;line-height:24px;color:#999;">读书感悟</span></p>
<p></p><p style="color:orange;margin-top:-30px;"><br>童年的梦，你还记得吗？<br>我们的梦或许不是去挖掘金币宝石这样的宝藏<br>而是成为更好的我们自己<br></p><p></p>
<p></p><p style="color:green;margin-top:-30px;"><br>儿时的梦想非常的简单、朴实<br>就是希望没有作业，可以天天玩<br>就是希望能够考入一所理想的大学<br>然而现在大学即将毕业，新的征程即将开始了<br>新的梦又是什么呢？<br></p><p></p>
<p></p><p style="color:#C56;margin-top:-30px;"><br>书中说的很好：<br>当一个人真心渴望某样东西时，整个宇宙都会联合起来帮助他完成梦想。<br>书中教导我们要去追寻自己真正喜欢的东西，<br>因为这是自己的天命<br></p><p></p>
<p></p><p style="color:orange;margin-top:-30px;"><br>男孩很幸运，<br>因为在他年少时遇到了启发他一生的人生导师——国王<br>国王告诉他天地之心，告诉他要追寻梦想。<br></p><p></p>
<p></p><p style="color:green;margin-top:-30px;"><br>水晶商人的梦想是去宗教圣地朝圣<br>可是他连第一步都没有迈出，<br>当他想要迈出的时候，<br>为时已晚。<br></p><p></p>
<p></p><p style="color:#C56;margin-top:-30px;"><br>男孩在水晶店赚足了钱，<br>他本可以继续留在那里工作，<br>他会赚很多钱，买更多的羊<br>但是他却选择了再次启程<br>因为他知道自己的天命，知道自己想要什么。<br></p><p></p>
<p></p><p style="color:orange;margin-top:-30px;"><br>英国的想成为炼金术士的人，<br>他的天命就是成为炼金术士<br>为此他读了无数的书却不得其法<br>真正的炼金术士给他的启示却是，去做，也只需要去做<br>仰望星空也需要脚踏实地嘛<br>理论水平再高也得去实践<br></p><p></p>
<p></p><p style="color:green;margin-top:-30px;"><br>沙漠里的女孩是男孩心爱的姑娘<br>女孩也钟情男孩<br>女孩支持男孩的梦想，甚至比男孩还要坚定<br>对女孩讲，遇见男孩就是她的天命<br>爱并不会阻碍一个人去追寻他的天命<br>还记得小时候看胡歌的电视剧——天外飞仙<br>里面有一句很经典的台词——爱到不爱才是真爱<br>因为，我不会让我的爱成为束缚你的理由<br></p><p></p>
<p></p><p style="color:#C56;margin-top:-30px;"><br>男孩遇到的最后一个人是炼金术士<br>如果说国王给了男孩世界观，<br>那么炼金术士则给了男孩方法论<br>他教会了男孩如何运用自己的本心<br>告知了他宝藏的方向<br></p><p></p>
<p></p><p style="color:orange;margin-top:-30px;"><br>然而，最后男孩的宝藏居然藏在了自己的家乡<br>这里蕴含了好多道理，也许最珍贵的东西就在自己身边<br>男孩走了一大圈却又回到原点，那他是不是白走了？<br>人生是不是也是这样？我们终究是空手来空手走<br>这一遭也是闭合的圆。那我们是不是就可以不走了？<br>可是，你不走就永远不知道自己的宝藏在哪里<br>你不走就不会遇到那些有趣的人，<br>就不会体会天地之心，<br>就不会知晓追求梦想的感觉。<br></p><p></p>
<p></p><p style="color:green;margin-top:-30px;"><br>最后，男孩借风问道：“既然你知道宝藏就在我的家乡，为什么还要骗我去金字塔下？”<br>炼金术士答道：“这样你才能欣赏到金字塔的风景，它们很漂亮”。<br>与开篇国王对男孩说的话不谋而合：<br>幸福的秘密就是去欣赏世界上所有的奇妙风景，但不要忘了汤匙里的油。<br>这是一本偏鸡汤的书，但是其中的很多道理真的需要自己体会过才能明悟。<br>我很羡慕那些年少时就遇到这本书的小朋友，<br>这本书就是每一个人的国王，指引着我们前方的路<br></p><p></p>
<p></p><p style="color:#C56;margin-top:-30px;"><br>读这本书时，我曾不止一次想到电影《死亡诗社》里的一句经典台词：<br>Medicine,law,business,engineering these are noble pursuits and necessary to sustain life. But poetry,beauty,romance,love… these are what we stay alive for!<br></p><p></p>
<p></p><p style="color:orange;margin-top:-30px;"><br>亲爱的朋友，<br>你的宝藏是什么?<br>你的天命又是什么呢？<br></p><p></p>
<p><hr></p>
<p></p><p style="font-size:20px;line-height:24px;">笔记摘抄</p><p></p>
<ol><br><li style="color:#b9632a;"> 绝大多数人似乎都很清楚别人该怎么过活，却对自己的一无所知。</li><br><li style="color:#b9632a;"> 在生命的重要时刻，我们却对发生在自己身上的事物无能为力，只能听天由命——这是世界上最大的谎言。</li><br><li style="color:#b9632a;"> 这股力量看似负面，实则引导你去完成你的天命。它能淬炼你的精神、砥砺你的愿力，因为这是这个星球上最伟大的真理：不管你是谁，也不论那是什么，只要你真心渴望一样东西，就放手去做，因为渴望是源自于天地之心；因为那就是你来到这世间的任务。</li><br><li style="color:#b9632a;"> 如果你一开始就去承诺你根本还未拥有的东西，你就会失去勇往直前的欲望。</li><br><li style="color:#b9632a;"> 幸福的秘密就是去欣赏世界上所有的奇妙风景，但不要忘了汤匙里的油。</li><br><li style="color:#b9632a;"> 千万不要把自己尚未到手的财富作为酬庸。</li><br><li style="color:#b9632a;"> 我就像大多数人一样——只肯相信自己要相信的，不肯去看清事情究竟真正是怎么一回事。</li><br><li style="color:#b9632a;"> 人们不需要恐惧未知，但看你有无能力去追求自己的需求与渴望。</li><br><li style="color:#b9632a;"> 当一个人真心渴望某样东西时，整个宇宙都会联合起来帮助你完成梦想。</li><br><li style="color:#b9632a;"> 魔鬼不是喝进人们嘴里的东西，而是从人们嘴巴里说出来的东西。</li><br><li style="color:#b9632a;"> 爱并不会阻碍一个人去追寻他的天命，如果他放弃追寻，那是因为它不是真爱……不是述说着宇宙之语的那种爱。</li><br><li style="color:#b9632a;"> ——那我为什么还要去听我的心在说什么？——因为你永远都无法教他安静下来，即使你假装没听见它在说什么，它还是会永远存在于你的灵魂中，不断地述说你对生活和世界的看法。</li><br><li style="color:#b9632a;"> 不可靠是由于你的措手不及。若你够了解你的心，就不会发生这种事。只要你了解它的梦想和希望，就会知道该怎么处理它们。你绝不可能逃离开自己的心，所以你最好还是听听它在说什么，这样你就不必害怕会遭遇措手不及的状况。<br></li><li style="color:#b9632a;"> 人总是害怕去追求自己最重要的梦想，因为他们觉得自己不配拥有，或者是觉得自己没有能力完成。</li><br><li style="color:#b9632a;"> 每一次的追寻在一开始都会有好运道，而最后能成功微笑的人，一定是通过了最严厉的考验。</li><br></ol>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/29/牧羊少年的奇幻之旅-读书笔记/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-读《悟空传》" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/14/读《悟空传》/">读《悟空传》</a>
    </h1>
  

        <a href="/2016/12/14/读《悟空传》/" class="archive-article-date">
  	<time datetime="2016-12-14T14:26:41.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-14</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我没看到金蝉子和孙悟空的胜利，他们最终也没有改变规则。<br>读书的时候，我非常渴望他们能打破什么，<br>这种心情就像自己想打破什么一样。<br>曾经的年少无知却踌躇满志，<br>曾经的不顾一切又不可一世，<br>是的，我们每个人都曾想过自己是这个世界的主角，<br>但总有一天，我们会发现别人并不在意自己如何，<br>我们总会长大，无奈却又期待着。</p>
<p>书中所有想寻找生命的正解的人，<br>都不得善终<br>却也总是有一些人，不知为何在奔波着<br>像沙僧一样，机械地寻找着琉璃盏的碎片<br>欺骗着自己，<br>好像只要能找齐碎片自己就可以重返天庭</p>
<p>我们每一个学生是不是都是曾经的沙僧，<br>为了去一所大学，每天刻苦地学习着不知道有什么用却貌似很重要的课本知识<br>小心地拼凑着碎片，只为了一纸入学通知书<br>终于到了自由的大学，<br>有一些人仍然过着沙僧那样的日子，继续拼凑<br>有些人会变成孙悟空和金蝉子<br>挣扎一下然后继续为了自己的未来恐慌着拼搏着<br>还有一些人，就是猪八戒和龙女这类为爱而活的人</p>
<p>我很羡慕得到爱情的人<br>好像看到心爱的人一眼，未来便不再可怕<br>得失、成败、生死都已不在重要<br>可以很从容地面对这一切<br>就像紫霞与悟空一同赴死，<br>就像白龙已不怕天条而为花果山降雨</p>
<p>未来是恐惧，但也有希望<br>就像我们不知道玄奘最后取到经没有，不知道他取到的又是什么<br>但他永远坚持着<br>他是金蝉子的时候坚持着，是玄奘的时候依旧坚持着<br>我曾以为金蝉子与如来打赌时，赌的是孙悟空<br>其实他赌的是自己，一直都是自己<br>如来辩不赢他，但他却也度不了苍生<br>也许前世的如来、王母、玉帝、太上都曾是金蝉子一般<br>追求着正解，苦苦寻求答案<br>但没有人知道，神也不知道，于是他们选择了放弃<br>放弃了解救苍生而选择欺骗<br>当欺骗开始之后就再也无法回头<br>所有想要揭开骗局的人都是十恶不赦<br>所有不遵守骗局规则的人也都是十恶不赦</p>
<p>没有人能告诉我们前方等着我们的是什么<br>人做不到，神也做不到<br>我们寻找生命的意义，有时会放弃思考这个根本没有答案的问题<br>我们都是凡人，做不到打破，只有坚守自己的本心<br>我常怀感动，因为虽然许多人都会随着岁月的流淌而不再追寻<br>但一直有人正追寻着，一直有人正坚持着<br>答案重要吗？与这种敢于探索，并一直追寻的精神相比，好像没那么重要了</p>
<p>金蝉子说，什么是如来<br>如来，就是如实道来<br>所以他说，我即如来<br>如来慌了<br>金蝉子死了，如来却输了<br>玄奘打破了界限，如来慌了<br>当玄奘打破界限之时，他取回的是白纸还是所谓的真经已经无所谓了<br>本没有大乘佛法，所谓大乘不过是金蝉子毕生所书<br>没有人见过真经，观音也打不开真经<br>到底这个这个骗局是如来、观音设的，还是金蝉子设的<br>我不知道<br>我只知道，玄奘说，无处不是佛<br>佛在心中又说他做甚？</p>
<p>混乱的时空<br>五百年前年、年后我早已分不清了<br>我只知道，取经路上玄奘找到了自己，找到了与金蝉子一样的路<br>有了路，未来便不再恐惧<br>你管他能不能成就自己想要的结果呢？<br>我来过，爱过，得到过<br>虽然都将失去，但是我的欲望证明我活过！<br>杨戬看到众神没有心窍，<br>到底是生着还是死的？</p>
<p>人生就是一场游戏<br>好好体验<br>眼前的所拥有的终将会离开你<br>不必抓，因为抓不住<br>但不能让自己悔，因为他们不会回！</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/14/读《悟空传》/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-canvas" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/10/canvas/">canvas的简单应用</a>
    </h1>
  

        <a href="/2016/12/10/canvas/" class="archive-article-date">
  	<time datetime="2016-12-10T10:45:37.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-10</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="canvas元素"><a href="#canvas元素" class="headerlink" title="canvas元素"></a>canvas元素</h2><p>1、在页面中添加canvas元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;</div></pre></td></tr></table></figure></p>
<p>2、canvas如何绘制图形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var c=document.getElementById(&quot;myCanvas&quot;);</div><div class="line">var context = c.getContext(&quot;2d&quot;);</div><div class="line">context.fillStyle = &quot;#FF00FF&quot;;</div><div class="line">context.fillRect(50,25,100,50);</div></pre></td></tr></table></figure></p>
<p>3、浏览器不支持canvas：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;</div><div class="line">	您的浏览器不支持canvas，请您升级或更换浏览器。</div><div class="line">&lt;/canvas&gt;</div></pre></td></tr></table></figure></p>
<p>4、浏览器检测<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var canvas = document.getElementById(&quot;myCanvas&quot;);</div><div class="line">if(!canvas.getContext(&quot;2d&quot;))&#123;</div><div class="line">	alert(&quot;您的浏览器不支持canvas！&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="canvas绘制简单图形"><a href="#canvas绘制简单图形" class="headerlink" title="canvas绘制简单图形"></a>canvas绘制简单图形</h2><p>1、直线：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">context.moveTo(x,y);</div><div class="line">context.lineTo(x,y);</div><div class="line">context.stroke();</div></pre></td></tr></table></figure></p>
<p>2、矩形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//指定填充区域，绘制填充区域的矩形</div><div class="line">context.fillStyle = &quot;#FF00FF&quot;;</div><div class="line">context.fillRect(0,0,200,100);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//指定轮廓线，绘制轮廓线</div><div class="line">context.strokeStyle = &quot;#FFFFFF&quot;;</div><div class="line">context.strokeRect(0,0,100,50);</div></pre></td></tr></table></figure>
<p>3、圆形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//圆区域，填充颜色</div><div class="line">context.fillStyle = &quot;#FF00FF&quot;;</div><div class="line">context.beginPath();</div><div class="line">context.arc(100,75,50,0,Math.PI*2,true);</div><div class="line">context.closePath();</div><div class="line">context.fill();</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//圆线</div><div class="line">context.strokeStyle = &quot;#FF00FF&quot;;</div><div class="line">context.beginPath();</div><div class="line">context.arc(100,75,50,0,Math.PI*2,true);</div><div class="line">context.stroke();</div></pre></td></tr></table></figure>
<p>4、三角形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//三角形区域，填充颜色</div><div class="line">context.fillStyle = &quot;red&quot;;</div><div class="line">context.beginPath();</div><div class="line">context.moveTo(25,25);</div><div class="line">context.lineTo(150,25);</div><div class="line">context.lineTo(25,150);</div><div class="line">context.fill();</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//三角形轮廓线</div><div class="line">context.strokeStyle = &quot;red&quot;;</div><div class="line">context.beginPath();</div><div class="line">context.moveTo(25,25);</div><div class="line">context.lineTo(150,25);</div><div class="line">context.lineTo(25,150);</div><div class="line">context.closePath();</div><div class="line">context.stroke();</div></pre></td></tr></table></figure>
<p>5、清空画布：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">context.clearRect(x,y,width,height);</div></pre></td></tr></table></figure></p>
<p>清除矩形区域内的所有图形，当x=0，y=0时，若width与height的值分别是画布的宽、高时，画布会被清空。<br>6、绘制贝塞尔曲线<br>quadraticCurveTo()方法可以绘制二次方贝塞尔曲线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">context.quadraticCurveTo(cp1x,cp1y,x,y);</div><div class="line">//(cp1x,cp1y)是控制点的坐标</div><div class="line">//(x,y)是终点坐标</div></pre></td></tr></table></figure></p>
<p>bezierCurveTo()方法可以绘制三次方贝塞尔曲线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">context.bezierCureTo(cp1x,cp1y,cp2x,cp2y,x,y);</div><div class="line">//(cp1x,cp1y)是第一个控制点的坐标</div><div class="line">//(cp2x,cp2y)是第二个控制点的坐标</div><div class="line">//(x,y)是终点坐标</div></pre></td></tr></table></figure></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/10/canvas/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-canvas的简单应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/10/canvas的简单应用/">canvas的简单应用</a>
    </h1>
  

        <a href="/2016/12/10/canvas的简单应用/" class="archive-article-date">
  	<time datetime="2016-12-10T10:45:37.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-10</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="canvas元素"><a href="#canvas元素" class="headerlink" title="canvas元素"></a>canvas元素</h2><p>1、在页面中添加canvas元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;</div></pre></td></tr></table></figure></p>
<p>2、canvas如何绘制图形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var c=document.getElementById(&quot;myCanvas&quot;);</div><div class="line">var context = c.getContext(&quot;2d&quot;);</div><div class="line">context.fillStyle = &quot;#FF00FF&quot;;</div><div class="line">context.fillRect(50,25,100,50);</div></pre></td></tr></table></figure></p>
<p>3、浏览器不支持canvas：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;</div><div class="line">	您的浏览器不支持canvas，请您升级或更换浏览器。</div><div class="line">&lt;/canvas&gt;</div></pre></td></tr></table></figure></p>
<p>4、浏览器检测<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var canvas = document.getElementById(&quot;myCanvas&quot;);</div><div class="line">if(!canvas.getContext(&quot;2d&quot;))&#123;</div><div class="line">	alert(&quot;您的浏览器不支持canvas！&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="canvas绘制简单图形"><a href="#canvas绘制简单图形" class="headerlink" title="canvas绘制简单图形"></a>canvas绘制简单图形</h2><p>1、直线：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">context.moveTo(x,y);</div><div class="line">context.lineTo(x,y);</div><div class="line">context.stroke();</div></pre></td></tr></table></figure></p>
<p>2、矩形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//指定填充区域，绘制填充区域的矩形</div><div class="line">context.fillStyle = &quot;#FF00FF&quot;;</div><div class="line">context.fillRect(0,0,200,100);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//指定轮廓线，绘制轮廓线</div><div class="line">context.strokeStyle = &quot;#FFFFFF&quot;;</div><div class="line">context.strokeRect(0,0,100,50);</div></pre></td></tr></table></figure>
<p>3、圆形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//圆区域，填充颜色</div><div class="line">context.fillStyle = &quot;#FF00FF&quot;;</div><div class="line">context.beginPath();</div><div class="line">context.arc(100,75,50,0,Math.PI*2,true);</div><div class="line">context.closePath();</div><div class="line">context.fill();</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//圆线</div><div class="line">context.strokeStyle = &quot;#FF00FF&quot;;</div><div class="line">context.beginPath();</div><div class="line">context.arc(100,75,50,0,Math.PI*2,true);</div><div class="line">context.stroke();</div></pre></td></tr></table></figure>
<p>4、三角形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//三角形区域，填充颜色</div><div class="line">context.fillStyle = &quot;red&quot;;</div><div class="line">context.beginPath();</div><div class="line">context.moveTo(25,25);</div><div class="line">context.lineTo(150,25);</div><div class="line">context.lineTo(25,150);</div><div class="line">context.fill();</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//三角形轮廓线</div><div class="line">context.strokeStyle = &quot;red&quot;;</div><div class="line">context.beginPath();</div><div class="line">context.moveTo(25,25);</div><div class="line">context.lineTo(150,25);</div><div class="line">context.lineTo(25,150);</div><div class="line">context.closePath();</div><div class="line">context.stroke();</div></pre></td></tr></table></figure>
<p>5、清空画布：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">context.clearRect(x,y,width,height);</div></pre></td></tr></table></figure></p>
<p>清除矩形区域内的所有图形，当x=0，y=0时，若width与height的值分别是画布的宽、高时，画布会被清空。<br>6、绘制贝塞尔曲线<br>quadraticCurveTo()方法可以绘制二次方贝塞尔曲线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">context.quadraticCurveTo(cp1x,cp1y,x,y);</div><div class="line">//(cp1x,cp1y)是控制点的坐标</div><div class="line">//(x,y)是终点坐标</div></pre></td></tr></table></figure></p>
<p>bezierCurveTo()方法可以绘制三次方贝塞尔曲线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">context.bezierCureTo(cp1x,cp1y,cp2x,cp2y,x,y);</div><div class="line">//(cp1x,cp1y)是第一个控制点的坐标</div><div class="line">//(cp2x,cp2y)是第二个控制点的坐标</div><div class="line">//(x,y)是终点坐标</div></pre></td></tr></table></figure></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/10/canvas的简单应用/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-node-js学习笔记（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/06/node-js学习笔记（一）/">node.js学习笔记（一）</a>
    </h1>
  

        <a href="/2016/12/06/node-js学习笔记（一）/" class="archive-article-date">
  	<time datetime="2016-12-06T10:44:47.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-06</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="node-js简介"><a href="#node-js简介" class="headerlink" title="node.js简介"></a>node.js简介</h2><p>node.js是单线程、异步、事件驱动的。<br>特点：速度快但是耗内存多。<br>开始第一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var http = require(&quot;http&quot;);</div><div class="line">http.createServer(function (request,response)&#123;</div><div class="line">	response.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;Text/html&apos;,charset=utf-8&#125;);</div><div class="line">	if(request.url!==&quot;/favicon.ico&quot;)&#123;        //清除第二次访问</div><div class="line">		console.log(&quot;在服务器端打印的内容&quot;);</div><div class="line">		response.write(&quot;服务器返回给前端的内容&quot;);</div><div class="line">		response.end(&quot;&quot;);        //如果没有这行，http协议结束不了！</div><div class="line">	&#125;</div><div class="line">&#125;).listen(8000);</div></pre></td></tr></table></figure></p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>函数调用有两种方式，一种是本地函数调用，另一种是调用其它文件中的函数。</p>
<h4 id="其他文件中的函数调用"><a href="#其他文件中的函数调用" class="headerlink" title="其他文件中的函数调用"></a>其他文件中的函数调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var otherFileFun = require(&quot;./module/other.js&quot;);</div></pre></td></tr></table></figure>
<p>这行代码是在本地文件中使用的，其目的类似对函数进行声明。这样我们就可以在本地文件中使用其他文件（other.js）中给我们开放接口的函数了。那么在other.js中如何开放接口呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//other.js文件中的内容：</div><div class="line">function other()&#123;</div><div class="line">	console.log(&quot;other File&quot;);</div><div class="line">&#125;</div><div class="line">module.exports = other;</div></pre></td></tr></table></figure></p>
<p>这是第一种开放接口的方法，但这样在一个js文件中只能开放一个函数的接口。还有另一种方式开放接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//重新写other.js的内容</div><div class="line">module.exports &#123;</div><div class="line">	func1:function()&#123;</div><div class="line">		console.log(&quot;function 1&quot;);</div><div class="line">		return &quot;function 1&quot;;</div><div class="line">	&#125;,</div><div class="line">	func2:function()&#123;</div><div class="line">		console.log(&quot;function 2&quot;);</div><div class="line">		return &quot;function 2&quot;;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用这种类似返回一个对象字面量的方式开放接口，就可以在一个js文件中同时开放几个函数的接口了。在本地文件中调用的时候，使用调用对象方法的形式就可以调用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var other1 = otherFileFun.func1();</div><div class="line">var other2 = otherFileFun[&quot;func2&quot;]();</div></pre></td></tr></table></figure></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/06/node-js学习笔记（一）/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-关于事件冒泡和事件捕获" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/04/关于事件冒泡和事件捕获/">关于事件冒泡和事件捕获</a>
    </h1>
  

        <a href="/2016/12/04/关于事件冒泡和事件捕获/" class="archive-article-date">
  	<time datetime="2016-12-04T11:38:42.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-04</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前在学jquery时，看到了事件冒泡。好多次面试的时候，面试官也考过事件冒泡。我原来一直以为，事件冒泡就是触发子元素的事件处理程序，子元素的事件处理程序完成后会继续执行其父元素的事件处理程序。完全没想到事件冒泡和事件捕获之间居然有关系！<br>“DOM2级事件”规定的事件流为3个阶段：事件捕获阶段–&gt;“处于目标”阶段–&gt;事件冒泡阶段，如下图所示：<br><img src="http://c.hiphotos.baidu.com/image/pic/item/4610b912c8fcc3cec16a432b9b45d688d43f207b.jpg" alt=""><br>记住理解了这张图，就可以很容易地理解事件捕获与事件冒泡之间的关系。<br>那么stopPropagation()方法的功能又是什么呢？实际上，这个方法的功能是取消事件的进一步捕获或冒泡。也就可以理解为，当调用这个方法之后，事件流中的事件捕获与事件冒泡全都被阻止了。<br>事件流的这种处理机制，让我们有两次可以在目标对象上操作事件的机会！<br>注：IE8-只有事件冒泡的流程。</p>
<p>参考资料：《javascript高级程序设计》（第三版）</p>
<p>如果小伙伴们想深入理解事件冒泡和事件捕获，可以参考知乎上的这篇文章：<br><a href="http://zhuanlan.zhihu.com/p/24159132" target="_blank" rel="external">FEX·饭记 - 解密W3C标准冒泡、捕获原理（分享自知乎网）</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/04/关于事件冒泡和事件捕获/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-用javascript写排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/01/用javascript写排序算法/">用javascript写排序算法</a>
    </h1>
  

        <a href="/2016/12/01/用javascript写排序算法/" class="archive-article-date">
  	<time datetime="2016-12-01T10:49:31.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-01</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天学习了冒泡排序和快速排序，阅读的是《啊哈！算法》。作者是用C语言描述的算法。看完之后，我用javascript敲了一遍。结果如下：</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function sort(myNum)&#123;</div><div class="line">	var temp = 0;</div><div class="line">	var flag = 0;</div><div class="line">	for(var i=0;i&lt;myNum.length-1;i++)&#123;</div><div class="line">		var flag = 0;</div><div class="line">		for(var j=0;j&lt;myNum.length-i;j++)&#123;</div><div class="line">			if(myNum[j]&gt;myNum[j+1])&#123;</div><div class="line">				flag = 1;</div><div class="line">				var temp = myNum[j];</div><div class="line">				myNum[j] = myNum[j+1];</div><div class="line">				myNum[j+1] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if(flag == 0)&#123;</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>冒泡排序的基本思想就是，每次比较两个相邻的元素如果它们的顺序错了，那就把它们交换。我写的这个算法，加了一个标志位，用来在排序结果已经正确的情况下将结果返回，提高算法效率。</p>
<h2 id="快速排序（快排）"><a href="#快速排序（快排）" class="headerlink" title="快速排序（快排）"></a>快速排序（快排）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function quickSort(array,left,right)&#123;</div><div class="line">	if(left&gt;right)&#123;</div><div class="line">		return;		                       //递归调用的返回条件</div><div class="line">	&#125;</div><div class="line">	var temp = array[left];</div><div class="line">	var i = left;</div><div class="line">	var j = right;</div><div class="line">	var t = 0;</div><div class="line">	while(i!=j)&#123;</div><div class="line">		while(array[j]&gt;=temp&amp;&amp;i&lt;j)&#123;        //从右侧向左找比基准数小的数</div><div class="line">			j--;</div><div class="line">		&#125;</div><div class="line">		while(array[i]&lt;=temp&amp;&amp;i&lt;j)&#123;		   //从左向右找比基准数大的数</div><div class="line">			i++;</div><div class="line">		&#125;</div><div class="line">		if(i&lt;j)&#123;                          </div><div class="line">			t = array[i];</div><div class="line">			array[i] = array[j];</div><div class="line">			array[j] = t;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	array[left] = array[i];</div><div class="line">	array[i] = temp;</div><div class="line">	quickSort(array,left,i-1);            //递归调用</div><div class="line">	quickSort(array,i+1,right);</div><div class="line">	return array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>快速排序的基本思想是二分。每次找一个基准数，将数组分成两部分，基准数左边的部分全比基准数小，基准数右边的全比基准数大。然后再在这两部分里分别找基准数，然后再分。</p>
<p>完整的代码我已经放到了我的github上：<br><a href="https://github.com/TimmyKingFree/algorithm" target="_blank" rel="external">https://github.com/TimmyKingFree/algorithm</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/01/用javascript写排序算法/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-关于寄生组合式继承的思考和验证" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/30/关于寄生组合式继承的思考和验证/">关于寄生组合式继承的思考和验证</a>
    </h1>
  

        <a href="/2016/11/30/关于寄生组合式继承的思考和验证/" class="archive-article-date">
  	<time datetime="2016-11-30T12:29:02.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-11-30</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在阅读《javascript高级程序设计》中的寄生组合式继承的时候，我产生了一个疑问，经过inheritPrototype函数之后，到底是将superType的原型整体复制了一份给subType原型对象，还是真的实现了一个原型链。产生这个问题的原因是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function inheritPrototype(subType,superType)&#123;</div><div class="line">				var prototype = Object(superType.prototype);</div><div class="line">				prototype.constructor = subType;</div><div class="line">				subType.prototype = prototype;</div><div class="line">			&#125;</div></pre></td></tr></table></figure></p>
<p>函数中的Object方法看上去像是新创造了一个对象，如果是新创造了一个对象的话，那么subType的原型就指向了一个新对象。还有一种可能就是单纯地使用Object方法（而不是通过构造函数的方式使用Object方法）只是创造了原对象（superType.prototype）的一个引用。<br>为此，做了一个验证,此验证的目的是检验Object方法作为普通函数调用（而不是构造函数）时的作用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var Timmy = &#123;name:&quot;Timmy&quot;,age:21&#125;;</div><div class="line">			var Timmy1 = Object(Timmy);</div><div class="line">			Timmy1.age = 22;</div><div class="line">			alert(Timmy.age);</div></pre></td></tr></table></figure></p>
<p>浏览器显示的结果是22。此结果可以证明prototype与superType.prototype指向的其实是同一个对象。<br>所以我猜想，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">prototype.constructor = subType;</div></pre></td></tr></table></figure></p>
<p>这行代码会让superType.prototype.constructor指向subType而不是superType！！！<br>于是做了以下实验：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function inheritPrototype(subType,superType)&#123;</div><div class="line">				var prototype = Object(superType.prototype);</div><div class="line">				prototype.constructor = subType;</div><div class="line">				subType.prototype = prototype;</div><div class="line">			&#125;</div><div class="line">			function superType(name)&#123;</div><div class="line">				this.name = name;</div><div class="line">				this.color = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">			&#125;</div><div class="line">			superType.prototype.sayName = function()&#123;</div><div class="line">				alert(this.name);</div><div class="line">			&#125;</div><div class="line">			function subType(name,age)&#123;</div><div class="line">				superType.call(this,name);</div><div class="line">				this.age = age;</div><div class="line">			&#125;</div><div class="line">			inheritPrototype(subType,superType);</div><div class="line">			subType.prototype.sayAge = function()&#123;</div><div class="line">				alert(this.age);</div><div class="line">			&#125;</div><div class="line">			alert(superType.prototype.constructor);</div></pre></td></tr></table></figure></p>
<p>果不其然，浏览器打印的结果是subType的函数声明。该结果证明，superType.prototype.constructor指向了subType。</p>
<hr>
<p>所以，我认为寄生式组合继承，就是将subType的原型直接指向了superType的原型。原型链的结果可能是不变的，但是原型链的结构与组合继承是不一样的。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/11/30/关于寄生组合式继承的思考和验证/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/30/hello-world/">Hello World</a>
    </h1>
  

        <a href="/2016/11/30/hello-world/" class="archive-article-date">
  	<time datetime="2016-11-30T11:55:35.334Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-11-30</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>很开心，终于有了自己的博客。花了一点时间研究了下hexo。很开心也很激动。<br>作为一个程序员，此刻我只想：</p>
<p>Hello world！</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/11/30/hello-world/#more">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Timmy King
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接1</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">一个在减肥的蓝胖纸&lt;br&gt;&lt;br&gt;阳光正能量小王子&lt;br&gt;…^_^…</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>